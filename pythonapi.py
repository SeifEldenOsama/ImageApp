# -*- coding: utf-8 -*-
"""PythonAPI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ybH0Pse-id-Fi1ChGcCKndE77IyJ-7FV
"""

import sys
import numpy as np
from PIL import Image
import cv2

def add_salt_pepper_noise(image, salt_prob=0.01, pepper_prob=0.01):
    img_array = np.array(image)
    if img_array.ndim == 2:
        channels = 1
    else:
        channels = img_array.shape[2]

    total_pixels = img_array.shape[0] * img_array.shape[1]
    num_salt = int(total_pixels * salt_prob)
    num_pepper = int(total_pixels * pepper_prob)

    coords = [np.random.randint(0, i - 1, num_salt) for i in img_array.shape[:2]]
    if channels == 1:
        img_array[coords[0], coords[1]] = 255
    else:
        img_array[coords[0], coords[1]] = [255] * channels

    coords = [np.random.randint(0, i - 1, num_pepper) for i in img_array.shape[:2]]
    if channels == 1:
        img_array[coords[0], coords[1]] = 0
    else:
        img_array[coords[0], coords[1]] = [0] * channels

    return Image.fromarray(img_array)

def add_gaussian_noise(image, mean=0, var=10):
    img_array = np.array(image)
    sigma = var ** 0.5
    gauss = np.random.normal(mean, sigma, img_array.shape)
    noisy = img_array + gauss
    noisy = np.clip(noisy, 0, 255).astype('uint8')
    return Image.fromarray(noisy)

def apply_gaussian_filter(image):
    img_array = np.array(image)
    filtered = cv2.GaussianBlur(img_array, (5, 5), 0)
    return Image.fromarray(filtered)

def apply_mean_filter(image):
    img_array = np.array(image)
    filtered = cv2.blur(img_array, (5, 5))
    return Image.fromarray(filtered)

def apply_median_filter(image):
    img_array = np.array(image)
    filtered = cv2.medianBlur(img_array, 5)
    return Image.fromarray(filtered)

def apply_erosion(image):
    img_array = np.array(image)
    kernel = np.ones((5, 5), np.uint8)
    eroded = cv2.erode(img_array, kernel, iterations=1)
    return Image.fromarray(eroded)

def apply_dilation(image):
    img_array = np.array(image)
    kernel = np.ones((5, 5), np.uint8)
    dilated = cv2.dilate(img_array, kernel, iterations=1)
    return Image.fromarray(dilated)

def region_filling_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    _, binary = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
    binary = cv2.bitwise_not(binary)
    h, w = binary.shape
    mask = np.zeros((h + 2, w + 2), np.uint8)
    filled = binary.copy()
    cv2.floodFill(filled, mask, (100, 100), 255)
    filled = cv2.bitwise_not(filled)
    return Image.fromarray(filled)

def boundary_extraction_image(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    _, binary = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    eroded = cv2.erode(binary, kernel, iterations=1)
    boundary = cv2.subtract(binary, eroded)
    return Image.fromarray(boundary)


def morphological_segmentation(image_path):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    _, binary = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    gradient = cv2.morphologyEx(binary, cv2.MORPH_GRADIENT, kernel)
    return Image.fromarray(gradient)

def watershed_segmentation(image_path):
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, binary = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    kernel = np.ones((3, 3), np.uint8)
    opening = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=2)
    sure_bg = cv2.dilate(opening, kernel, iterations=3)
    dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
    _, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)
    sure_fg = np.uint8(sure_fg)
    unknown = cv2.subtract(sure_bg, sure_fg)
    _, markers = cv2.connectedComponents(sure_fg)
    markers = markers + 1
    markers[unknown == 255] = 0
    markers = cv2.watershed(image, markers)
    result = image.copy()
    result[markers == -1] = [0, 0, 255]
    return Image.fromarray(cv2.cvtColor(result, cv2.COLOR_BGR2RGB))


def main():
    if len(sys.argv) < 4:
        print("Usage: python image_processing.py <input_path> <output_path> <operation>")
        return

    input_path = sys.argv[1]
    output_path = sys.argv[2]
    operation = sys.argv[3]

    if operation in ["region_fill", "boundary_extract"]:
        if operation == "region_fill":
            result = region_filling_image(input_path)
        elif operation == "boundary_extract":
            result = boundary_extraction_image(input_path)
    elif operation == "morph_segment":
               result = morphological_segmentation(input_path)
    elif operation == "watershed_segment":
               result = watershed_segmentation(input_path)

    else:
        image = Image.open(input_path)

        if operation == "salt_pepper":
            result = add_salt_pepper_noise(image)
        elif operation == "gaussian_noise":
            result = add_gaussian_noise(image)
        elif operation == "gaussian_filter":
            result = apply_gaussian_filter(image)
        elif operation == "mean_filter":
            result = apply_mean_filter(image)
        elif operation == "median_filter":
            result = apply_median_filter(image)
        elif operation == "erosion":
            result = apply_erosion(image)
        elif operation == "dilation":
            result = apply_dilation(image)
        else:
            print("Unknown operation:", operation)
            return

    result.save(output_path)
    print("Saved:", output_path)

if __name__ == "__main__":
    main()